# git clone https://github.com/timefullkr/jshs-2024-11-21.git

NEIS_API_KEY = "85da0158c01d40eeb9e69c9b89d3477d"

# AI 스쿨랭 http://school-len.jshs.kr/ 분석및 커스터마이
## 사이트 기능
- 현재 날짜 기준 전후 3일간의 급식 메뉴 확인 가능 (주말 제외)
- 각 학교별 급식 메뉴가 카드 형태로 표시
- 카드에는 학교명, 급식 메뉴, AI 리뷰, 평가 점수, 좋아요 버튼 포함
- AI는 영양학적 평가와 학생 선호도 측면에서 리뷰 작성
- 급식 메뉴당 5회까지 좋아요 클릭 가능
- 좋아요 수는 실시간으로 모든 사용자에게 반영
- 30초마다 좋아요 수에 따라 카드 순서 자동 재정렬
- 처음 로드 시 급식 카드가 평가 합산 점수 순으로 정렬되며
- 로드 후 30초마다 사용자 좋아요 클릭 합산 수 순으로 재정렬

## 프로젝트 폴더 구성
```
jshs-2203-11-21/
    ├── data/
    │   └── school_meals.db        # SQLite 데이터베이스 파일 (급식정보, 리뷰, 방문자수 저장)
    │
    ├── static/
    │   ├── css/                   # CSS 스타일시트 파일들
    │   │   └── style.css         
    │   └── help/                  # 도움말 관련 정적 파일들
    │       └── guide.html
    │
    ├── templates/
    │   ├── html/                  # HTML 템플릿 파일들
    │   │   └── index.html        # 메인 페이지 템플릿
    │   └── js/                    # JavaScript 파일들
    │       ├── app.js            # 메인 애플리케이션 로직
    │       └── websocket.js      # WebSocket 통신 관련 로직
    │
    ├── main.py                    # FastAPI 메인 애플리케이션 (라우팅, 엔드포인트 정의)
    ├── database.py               # 데이터베이스 연결 및 쿼리 처리
    ├── neis_api.py              # NEIS API 연동 (학교 급식 정보 조회)
    ├── chatgpt_api.py           # ChatGPT API 연동 (급식 메뉴 리뷰 생성)
    ├── websocket_manager.py     # WebSocket 연결 관리 (실시간 업데이트)
    ├── requirements.txt         # 프로젝트 의존성 목록
    └── .env                     # 환경 변수 설정 (API 키, DB 설정 등)
```
## 백엔드 코드 분석
### main.py 코드 분석
```
# 필요한 라이브러리 임포트
# main.py

# 시스템 관련 라이브러리
import os                  # 운영체제 기능 사용
import json               # JSON 데이터 처리
import logging           # 로깅 기능
from pathlib import Path  # 파일 경로 처리
from datetime import datetime, timedelta  # 날짜/시간 처리

# FastAPI 관련 라이브러리  
import uvicorn            # ASGI 서버
from fastapi import FastAPI, HTTPException, WebSocket, WebSocketDisconnect  # FastAPI 프레임워크
from fastapi.responses import FileResponse    # 파일 응답 처리
from fastapi.staticfiles import StaticFiles   # 정적 파일 처리

# 환경설정 관련 라이브러리
from dotenv import load_dotenv  # 환경변수 로드

# 로깅 관련 라이브러리
from logging.handlers import RotatingFileHandler  # 로그 파일 순환 처리

# 타입 힌트 라이브러리
from typing import AsyncGenerator  # 비동기 제너레이터 타입

# 커스텀 모듈
from database import Database                # DB 처리
from neis_api import NeisService            # 나이스 API 연동
from chatgpt_api import GPT_Client_API      # ChatGPT API 연동
from websocket_manager import ConnectionManager  # WebSocket 연결 관리

# 환경 변수 로드
load_dotenv()

# 기본 설정
BASE_DIR = Path(__file__).resolve().parent

# 로그 디렉토리 설정
LOG_DIR = BASE_DIR / "logs"
LOG_DIR.mkdir(parents=True, exist_ok=True)  # 디렉토리가 없으면 생성

# 로그 파일 경로 설정
LOG_FILE = LOG_DIR / "app.log"

# 로깅 설정
logger = logging.getLogger("uvicorn")
logger.setLevel(logging.INFO)

# 로테이팅 파일 핸들러 설정 (파일 크기 5MB, 최대 5개 파일)
rotating_handler = RotatingFileHandler(
    LOG_FILE,
    maxBytes=5*1024*1024,  # 5MB
    backupCount=5,
    encoding='utf-8'
)
# 로그 포맷터 설정 - 시간, 로거이름, 로그레벨, 메시지를 포함하는 포맷 지정
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# 로테이팅 핸들러에 포맷터 적용
rotating_handler.setFormatter(formatter)

# 로거에 핸들러 추가
logger.addHandler(rotating_handler)

# 콘솔 핸들러 추가 (선택 사항)
console_handler = logging.StreamHandler()
console_handler.setFormatter(formatter)
logger.addHandler(console_handler)

# 데이터베이스 초기화
db = Database(str(BASE_DIR / "data" / "school_meals.db"))

# NEIS 서비스 초기화
neis_api = NeisService(api_key=os.getenv('NEIS_API_KEY'))

# AI 서비스 초기화
ai_client = GPT_Client_API().create()

if not ai_client:
    logger.critical("AI 서비스 초기화에 실패했습니다.")
    raise RuntimeError("Failed to initialize AI service")

# WebSocket 매니저 초기화
ws_manager = ConnectionManager()

async def lifespan(app: FastAPI) -> AsyncGenerator:
    """
    Lifespan 이벤트 핸들러
    - 애플리케이션 시작 시 데이터베이스 초기화
    - 애플리케이션 종료 시 데이터베이스 연결 종료
    """
    try:
        # 애플리케이션 시작 시 데이터베이스 초기화
        await db.init_db()
        # logger.info("애플리케이션이 시작되었습니다.")
        yield
    finally:
        # 애플리케이션 종료 시 데이터베이스 연결 종료
        await db.close()
        # logger.info("애플리케이션이 종료되었습니다.")

# FastAPI 앱 초기화 (Lifespan 이벤트 핸들러 사용)
app = FastAPI(lifespan=lifespan)

# 정적 파일 마운트
app.mount("/templates", StaticFiles(directory=str(BASE_DIR / "templates")), name="templates")
app.mount("/static", StaticFiles(directory=str(BASE_DIR / "static")), name="static")
app.mount("/js", StaticFiles(directory=str(BASE_DIR / "templates" / "js")), name="js")
app.mount("/css", StaticFiles(directory=str(BASE_DIR / "static" / "css")), name="css")
app.mount("/help", StaticFiles(directory=str(BASE_DIR / "static" / "help")), name="help")

# WebSocket 엔드포인트 추가
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    client_id = websocket.query_params.get("client_id")
    if not client_id:
        await websocket.close(code=1008, reason="Client ID is required")
        logger.warning("클라이언트 ID가 제공되지 않아 WebSocket 연결이 종료되었습니다.")
        return

    await ws_manager.connect(websocket, client_id)
    # logger.info(f"클라이언트 {client_id}가 WebSocket에 연결되었습니다.")
    try:
        while True:
            data = await websocket.receive_text()
            logger.debug(f"클라이언트 {client_id}로부터 받은 데이터: {data}")
            # 클라이언트로부터의 메시지 처리 로직이 필요한 경우 여기에 추가
    except WebSocketDisconnect:
        await ws_manager.disconnect(client_id)
        # logger.info(f"클라이언트 {client_id}의 WebSocket 연결이 종료되었습니다.")
    except Exception as e:
        await ws_manager.disconnect(client_id)
        logger.error(f"WebSocket 연결 중 오류 발생: {e}")

# API 라우트
@app.get("/")
async def home():
    """메인 페이지"""
    today = datetime.now().strftime("%Y%m%d")
    try:
        count = await db.increment_visits(today)
        # logger.info(f"오늘({today})의 방문자 수가 {count}으로 증가되었습니다.")
    except Exception as e:
        logger.error(f"방문자 수 증가 중 오류 발생: {e}")
        raise HTTPException(status_code=500, detail="서버 내부 오류가 발생했습니다.")
    
    return FileResponse(str(BASE_DIR / "templates" / "html" / "index.html"))

@app.get("/api/visits/today")
async def get_today_visits():
    """오늘의 방문자 수"""
    today = datetime.now().strftime("%Y%m%d")
    try:
        count = await db.get_today_visits(today)
        # logger.info(f"오늘({today})의 방문자 수 조회: {count}")
        return {"count": count}
    except Exception as e:
        logger.error(f"오늘의 방문자 수 조회 중 오류 발생: {e}")
        raise HTTPException(status_code=500, detail="서버 내부 오류가 발생했습니다.")

@app.get("/api/meals/{date}")
async def get_meals(date: str):
    """급식 정보 조회"""
    try:
        target_date = datetime.strptime(date, "%Y-%m-%d")
        date_str = target_date.strftime("%Y%m%d")

        meals = await db.get_meals(date_str)
        if not meals:
            # logger.info(f"{date_str}의 급식 정보가 데이터베이스에 없으므로 NEIS API를 통해 가져옵니다.")
            meals = await neis_api.fetch_school_meals(target_date, db)
        
        # logger.info(f"{date_str}의 급식 정보 조회 완료. 학교 수: {len(meals)}")
        return meals
    except ValueError:
        logger.warning(f"유효하지 않은 날짜 형식 요청: {date}")
        raise HTTPException(status_code=400, detail="유효하지 않은 날짜 형식입니다.")
    except Exception as e:
        logger.error(f"급식 정보 조회 중 오류 발생: {e}")
        raise HTTPException(status_code=500, detail="서버 내부 오류가 발생했습니다.")

@app.get("/api/review/{date}/{school_code}")
async def get_review(date: str, school_code: str):
    """리뷰 조회 및 생성"""
    try:
        target_date = datetime.strptime(date, "%Y-%m-%d")
        date_str = target_date.strftime("%Y%m%d")

        review = await db.get_review(date_str, school_code)
        if not review:
            meals = await db.get_meals(date_str)
            meal = next((m for m in meals if m['school_code'] == school_code), None)

            if meal and meal.get('lunch_menu'):
                try:
                    review_text, nutri_score, pref_score = await ai_client.generate_menu_review(meal['lunch_menu'])
                    error_flag = 0
                    # logger.info(f"리뷰 생성 성공: {date_str}, {school_code}")
                except Exception as e:
                    logger.error(f"리뷰 생성 중 오류 발생: {e}")
                    review_text = "리뷰를 생성하는 중 오류가 발생했습니다."
                    nutri_score = 0
                    pref_score = 0
                    error_flag = 1

                await db.save_review(date_str, school_code, review_text, nutri_score, pref_score, error_flag)

                if error_flag == 0:
                    review = {
                        "review": review_text,
                        "nutri_score": nutri_score,
                        "pref_score": pref_score,
                        "reactions": {"likes": 0}
                    }
                else:
                    review = {
                        "review": review_text,
                        "nutri_score": 0,
                        "pref_score": 0,
                        "nutri_stars": "",
                        "pref_stars": "",
                        "reactions": {"likes": 0}
                    }
            else:
                logger.warning(f"급식 메뉴가 없어서 리뷰를 생성할 수 없습니다: {date_str}, {school_code}")
                raise HTTPException(status_code=404, detail="리뷰를 생성할 수 없습니다.")
        
        # logger.info(f"{date_str}, {school_code}의 리뷰 조회 완료.")
        return review
    except ValueError:
        logger.warning(f"유효하지 않은 날짜 형식 요청: {date}")
        raise HTTPException(status_code=400, detail="유효하지 않은 날짜 형식입니다.")
    except HTTPException as he:
        raise he
    except Exception as e:
        logger.error(f"리뷰 조회 중 오류 발생: {e}")
        raise HTTPException(status_code=500, detail="서버 내부 오류가 발생했습니다.")

@app.post("/api/reaction/{date}/{school_code}/{reaction_type}")
async def handle_reaction(date: str, school_code: str, reaction_type: str):
    """반응 처리"""
    try:
        if reaction_type != "like":
            logger.warning(f"유효하지 않은 반응 타입 요청: {reaction_type}")
            raise HTTPException(status_code=400, detail="Invalid reaction type")

        target_date = datetime.strptime(date, "%Y-%m-%d")
        date_str = target_date.strftime("%Y%m%d")

        result = await db.handle_reaction(date_str, school_code, reaction_type)
        
        if result:
            # 반응이 성공적으로 처리된 경우, 모든 클라이언트에게 업데이트 브로드캐스트
            message = json.dumps({
                "type": "reaction",
                "school_code": school_code,
                "likes": result.get("likes", 0)
            })
            await ws_manager.broadcast(message)
            # logger.info(f"반응 처리 및 브로드캐스트 완료: {message}")
        else:
            logger.warning(f"반응 처리 실패: {date_str}, {school_code}, {reaction_type}")

        return result

    except ValueError:
        logger.warning(f"유효하지 않은 날짜 형식 요청: {date}")
        raise HTTPException(status_code=400, detail="유효하지 않은 날짜 형식입니다.")
    except HTTPException as he:
        raise he
    except Exception as e:
        logger.error(f"반응 처리 중 오류 발생: {e}")
        raise HTTPException(status_code=500, detail="서버 내부 오류가 발생했습니다.")

@app.get("/api/reactions/{date}")
async def get_all_reactions(date: str):
    """모든 학교의 반응 수 가져오기"""
    try:
        target_date = datetime.strptime(date, "%Y-%m-%d")
        date_str = target_date.strftime("%Y%m%d")
        result = await db.handle_reaction_all(date_str)
        # logger.info(f"{date_str}의 모든 학교 반응 수 조회 완료.")
        return result
    except ValueError:
        logger.warning(f"유효하지 않은 날짜 형식 요청: {date}")
        raise HTTPException(status_code=400, detail="유효하지 않은 날짜 형식입니다.")
    except Exception as e:
        logger.error(f"모든 반응 수 조회 중 오류 발생: {e}")
        raise HTTPException(status_code=500, detail="서버 내부 오류가 발생했습니다.")

@app.get("/api/visits/total")
async def get_total_visits():
    """총 방문자 수 조회"""
    try:
        count = await db.get_total_visits()
        # logger.info(f"총 방문자 수 조회 완료: {count}")
        return {"count": count}
    except Exception as e:
        logger.error(f"총 방문자 수 조회 중 오류 발생: {e}")
        raise HTTPException(status_code=500, detail="서버 내부 오류가 발생했습니다.")

@app.get("/api/dates")
async def get_dates():
    """날짜 범위 조회"""
    try:
        today = datetime.now()
        dates = [(today + timedelta(days=i)).strftime("%Y-%m-%d") for i in range(-3, 4)]
        selected_date = today.strftime("%Y-%m-%d")
        # logger.info(f"날짜 범위 조회 완료: {dates}, 선택된 날짜: {selected_date}")
        return {"dates": dates, "selected_date": selected_date}
    except Exception as e:
        logger.error(f"날짜 범위 조회 중 오류 발생: {e}")
        raise HTTPException(status_code=500, detail="서버 내부 오류가 발생했습니다.")

if __name__ == "__main__":
    # 환경 변수에서 HOST와 PORT 가져오기 (기본값 설정)
    HOST = os.getenv('HOST', '192.168.200.100')
    PORT = int(os.getenv('PORT', 8000))
    
    uvicorn.run(
        "main:app",
        host=HOST,
        port=PORT,
        reload=True
    )

```

### 데이터베이스 관리 모듈( database.py) 분석
```
# database.py

import os
import sqlite3
import asyncio
from pathlib import Path

class Database:
    def __init__(self, db_path: str):
        self.db_path = db_path
        
    def init_db(self):
        """데이터베이스 초기화"""
        with sqlite3.connect(self.db_path) as conn:
            c = conn.cursor()
            # 급식 테이블
            c.execute('''
                CREATE TABLE IF NOT EXISTS meals (
                    date TEXT,
                    school_code TEXT,
                    school_name TEXT,
                    lunch_menu TEXT,
                    PRIMARY KEY (date, school_code)
                )
            ''')
            # 리뷰 테이블
            c.execute('''
                CREATE TABLE IF NOT EXISTS reviews (
                    date TEXT,
                    school_code TEXT,
                    review_text TEXT,
                    nutri_score REAL,
                    pref_score REAL,
                    error_flag INTEGER DEFAULT 0,
                    PRIMARY KEY (date, school_code)
                )
            ''')
            # 반응 테이블 (싫어요 컬럼 제거)
            c.execute('''
                CREATE TABLE IF NOT EXISTS reactions (
                    date TEXT,
                    school_code TEXT,
                    likes INTEGER DEFAULT 0,
                    PRIMARY KEY (date, school_code)
                )
            ''')
            # 방문자 테이블
            c.execute('''
                CREATE TABLE IF NOT EXISTS visits (
                    date TEXT PRIMARY KEY,
                    count INTEGER DEFAULT 0
                )
            ''')

    async def execute(self, query: str, params: tuple = None) -> list:
        """비동기 데이터베이스 실행 함수"""
        def _execute():
            with sqlite3.connect(self.db_path) as conn:
                cur = conn.cursor()
                if params:
                    cur.execute(query, params)
                else:
                    cur.execute(query)
                conn.commit()
                return cur.fetchall()
        return await asyncio.to_thread(_execute)

    # 급식 관련 메서드
    async def get_meals(self, date_str: str) -> list:
        """급식 정보 조회"""
        rows = await self.execute('''
            SELECT school_code, school_name, lunch_menu
            FROM meals
            WHERE date = ? AND lunch_menu != '급식 정보 없음'
        ''', (date_str,))
        return [{"school_code": row[0], "school_name": row[1], "lunch_menu": row[2]} for row in rows]

    async def save_meal(self, date_str: str, school_code: str, school_name: str, menu: str):
        """급식 정보 저장"""
        await self.execute(
            'INSERT OR REPLACE INTO meals (date, school_code, school_name, lunch_menu) VALUES (?, ?, ?, ?)',
            (date_str, school_code, school_name, menu)
        )

    # 리뷰 관련 메서드
    async def get_review(self, date_str: str, school_code: str):
        """리뷰 정보 조회"""
        rows = await self.execute('''
            SELECT r.review_text, r.error_flag, r.nutri_score, r.pref_score,
                   COALESCE(rc.likes, 0) as likes
            FROM reviews r
            LEFT JOIN reactions rc ON r.date = rc.date AND r.school_code = rc.school_code
            WHERE r.date = ? AND r.school_code = ?
        ''', (date_str, school_code))

        if rows:
            row = rows[0]
            error_flag = row[1]
            if error_flag:
                return None

            nutri_score = float(row[2])
            pref_score = float(row[3])
            
            return {
                "review": row[0],
                "nutri_score": nutri_score,
                "pref_score": pref_score,
                "reactions": {"likes": row[4]}
            }
        return None

    async def save_review(self, date_str: str, school_code: str, review_text: str, nutri_score: float, pref_score: float, error_flag: int = 0):
        """리뷰 저장"""
        await self.execute(
            '''INSERT OR REPLACE INTO reviews 
            (date, school_code, review_text, nutri_score, pref_score, error_flag) 
            VALUES (?, ?, ?, ?, ?, ?)''',
            (date_str, school_code, review_text, nutri_score, pref_score, error_flag)
        )

    # 반응 관련 메서드
    async def handle_reaction_all(self, date_str: str):
        result = await self.execute(
            'SELECT school_code, likes FROM reactions WHERE date = ?',
            (date_str,)
        )
        
        if result:
            reactions = {}
            for row in result:
                school_code, likes = row
                reactions[school_code] = {"likes": likes}
            return reactions
        return {}

    async def handle_reaction(self, date_str: str, school_code: str, reaction_type: str):
        """반응 처리"""
        # 레코드가 없으면 생성
        await self.execute(
            'INSERT OR IGNORE INTO reactions (date, school_code, likes) VALUES (?, ?, 0)',
            (date_str, school_code)
        )

        # 좋아요 업데이트
        if reaction_type == 'like':
            await self.execute(
                'UPDATE reactions SET likes = likes + 1 WHERE date = ? AND school_code = ?',
                (date_str, school_code)
            )

        # 업데이트된 값 조회
        result = await self.execute(
            'SELECT likes FROM reactions WHERE date = ? AND school_code = ?',
            (date_str, school_code)
        )
        
        if result:
            likes = result[0][0]
            return {"school_code": school_code, "likes": likes}
        return {}
    
    # 방문자 관련 메서드
    async def increment_visits(self, date_str: str) -> int:
        """방문자 수 증가"""
        await self.execute(
            'INSERT INTO visits (date, count) VALUES (?, 1) ON CONFLICT(date) DO UPDATE SET count = count + 1',
            (date_str,)
        )
        result = await self.execute('SELECT count FROM visits WHERE date = ?', (date_str,))
        return result[0][0] if result else 0

    async def get_today_visits(self, date_str: str) -> int:
        """오늘의 방문자 수 조회"""
        result = await self.execute('SELECT count FROM visits WHERE date = ?', (date_str,))
        return result[0][0] if result else 0

    async def get_total_visits(self) -> int:
        """총 방문자 수 조회"""
        result = await self.execute('SELECT COALESCE(SUM(count), 0) FROM visits')
        return result[0][0] if result else 0
```

### NEIS API 관리 모듈( neis_api.py) 분석
```
import os
import asyncio
import httpx
from typing import List, Dict, Any, Optional
from fastapi import HTTPException

class NeisAPI:
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://open.neis.go.kr/hub"
        
    async def get_schools(self, atpt_code: str = 'T10', school_type: str = '고등학교') -> List[Dict[str, Any]]:
        """학교 목록 조회"""
        async with httpx.AsyncClient() as client:
            try:
                response = await client.get(
                    f"{self.base_url}/schoolInfo",
                    params={
                        'KEY': self.api_key,
                        'Type': 'json',
                        'pIndex': '1',
                        'pSize': '1000',
                        'ATPT_OFCDC_SC_CODE': atpt_code,
                        'SCHUL_KND_SC_NM': school_type
                    }
                )
                
                data = response.json()
                if 'schoolInfo' in data:
                    schools = data['schoolInfo'][1]['row']
                    return sorted(
                        schools,
                        key=lambda x: self._normalize_school_name(x['SCHUL_NM'])
                    )
                return []
                
            except Exception as e:
                print(f"Error fetching schools: {str(e)}")
                return []
                
    async def get_meal(self, school_code: str, date: str, atpt_code: str = 'T10') -> Optional[str]:
        """급식 정보 조회"""
        async with httpx.AsyncClient() as client:
            try:
                response = await client.get(
                    f"{self.base_url}/mealServiceDietInfo",
                    params={
                        'KEY': self.api_key,
                        'Type': 'json',
                        'pIndex': '1',
                        'pSize': '100',
                        'ATPT_OFCDC_SC_CODE': atpt_code,
                        'SD_SCHUL_CODE': school_code,
                        'MLSV_YMD': date
                    }
                )
                
                data = response.json()
                if 'mealServiceDietInfo' in data:
                    menu = data['mealServiceDietInfo'][1]['row'][0]['DDISH_NM']
                    return self._process_menu(menu)
                return None
                
            except Exception as e:
                print(f"Error fetching meal for school {school_code}: {str(e)}")
                return None

    def _normalize_school_name(self, name: str) -> str:
        """학교명 정규화"""
        return name

    def _process_menu(self, menu: str) -> str:
        """메뉴 문자열 처리"""
        return ', '.join([
            item.split("(")[0].strip()
            for item in menu.split("<br/>")
        ])

    def validate_api_key(self) -> bool:
        """API 키 유효성 검증"""
        if not self.api_key:
            print("NEIS API key is not set")
            return False
        return True

class NeisService:
    def __init__(self, api_key: str):
        self.api = NeisAPI(api_key)
        
    async def fetch_school_meals(self, target_date, db) -> List[Dict[str, Any]]:
        """학교 급식 정보 조회 및 업데이트"""
        try:
            if not self.api.validate_api_key():
                raise Exception("Invalid NEIS API key")

            date_str = target_date.strftime("%Y%m%d")
            
            # 학교 목록 조회
            schools = await self.api.get_schools()
            if not schools:
                raise Exception("Failed to fetch school list")

            # 각 학교의 급식 정보 조회
            tasks = []
            for school in schools:
                tasks.append(self._fetch_and_save_meal(school, date_str, db))

            await asyncio.gather(*tasks)

            # 저장된 급식 정보 반환
            return await db.get_meals(date_str)

        except Exception as e:
            print(f"Error in fetch_school_meals: {str(e)}")
            raise HTTPException(status_code=500, detail="급식 정보를 가져오는데 실패했습니다.")

    async def _fetch_and_save_meal(self, school: Dict[str, Any], date_str: str, db) -> None:
        """개별 학교 급식 정보 조회 및 저장"""
        try:
            school_name = self.api._normalize_school_name(school['SCHUL_NM'])
            school_code = school['SD_SCHUL_CODE']
            
            menu = await self.api.get_meal(school_code, date_str)
            if menu is None:
                menu = "급식 정보 없음"
                
            await db.save_meal(date_str, school_code, school_name, menu)
            
        except Exception as e:
            print(f"Error processing meal for {school_name}: {str(e)}")
            await db.save_meal(date_str, school_code, school_name, "급식 정보 없음")
```

### ChatGPT API 관리 모듈( chatgpt_api.py) 분석
```
import os
from openai import AsyncOpenAI

class GPT_Client:
    def __init__(self, api_key: str):
        self.client = AsyncOpenAI(api_key=api_key)

    async def generate_menu_review(self, menu: str):
        """메뉴 리뷰 생성"""
        # 급식 정보가 없는 경우 처리
        if not menu or menu == "급식 정보 없음":
            return "급식 정보가 없습니다.", 0.0, 0.0

        try:
            # AI에 보낼 메시지 만들기
            prompt = f"""
            다음 학교 급식 메뉴에 대해 영양학적 관점과 학생 선호도 관점에서 각각 분석하고 평가하는 리뷰를 작성해주세요:
           
            다음을 준수해주세요.
            리뷰는 450자 이내로 작성해주세요.
            '이번 학교 급식 메뉴는...' , '이번 학교 급식은...' 등 사용하지 마십시고 다양한 시작어를 사용해야 합니다.
            시작없이 바로 리뷰를 하는 방법도 가끔 사용하시도록 합니다.
            반듯이 존칭어를 사용해야 합니다.
            학교 점심 메뉴: {menu}

            반드시 마지막에 줄바꿈을 하고 5점 만점으로 각각의 평가 점수를 다음처럼 추가해주세요.
            #NUTRI_RATE:영양학적 평가점수
            #PREF_RATE:학생 선호도 평가점수
            """

            # AI에 요청 보내기
            response = await self.client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {"role": "system", "content": "당신은 학교 급식을 평가하는 영양 전문가입니다."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.7,
                max_tokens=500
            )

            # AI 응답 처리하기
            review_text = response.choices[0].message.content.strip()
            review_text = review_text.replace('\n\n', '\n')
            lines = review_text.split('\n')

            # 기본 평가 점수
            nutri_score = 3.0
            pref_score = 3.0
            review_lines = []

            # 응답 분석
            for line in lines:
                if line.startswith('#NUTRI_RATE:'):
                    try:
                        nutri_score = float(line.replace('#NUTRI_RATE:', '').strip())
                        nutri_score = min(max(nutri_score, 1.0), 5.0)  # 1~5 사이로 제한
                    except:
                        pass
                elif line.startswith('#PREF_RATE:'):
                    try:
                        pref_score = float(line.replace('#PREF_RATE:', '').strip())
                        pref_score = min(max(pref_score, 1.0), 5.0)  # 1~5 사이로 제한
                    except:
                        pass
                elif line.strip():
                    review_lines.append(line.strip())

            # 최종 리뷰 텍스트 만들기
            final_review = '\n'.join(review_lines)
            if not final_review:
                return "메뉴 분석 결과를 생성하지 못했습니다.", 3.0, 3.0

            return final_review, nutri_score, pref_score

        except Exception as e:
            print(f"메뉴 분석 중 오류 발생: {str(e)}")
            return "메뉴 분석 중 오류가 발생했습니다.", 3.0, 3.0

    def check_api_key(self):
        """API 키 확인"""
        if not self.client.api_key:
            return False
        return True

class GPT_Client_API:
    """
    AI 서비스 생성을 도와주는 클래스
    - AI 서비스 생성에 필요한 설정을 처리합니다.
    """
    def create(self):
        """AI 서비스 만들기"""
        # 환경 변수에서 API 키 가져오기
        api_key = os.getenv('OPENAI_API_KEY')
        
        # API 키가 없으면 None 반환
        if not api_key:
            print("OpenAI API key를 찾을 수 없습니다.")
            return None
            
        # API 키가 있으면 AIService 인스턴스 생성
        return GPT_Client(api_key)
```
## 프론트엔드 코드 분석

### index.html 분석
```
<!DOCTYPE html>
<html lang="ko">
<head>
    <!-- 기본 메타 정보 설정 -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="AI 스쿨랭 - 인공지능이 평가하는 오늘의 학교 급식 리뷰, 제주과학고등학교 1학년 인공지능 기초 과목 실습작">

    <!-- 사이트 제목 -->
    <title>AI 스쿨랭</title>

    <!-- 부트스트랩 CSS 파일 로드 -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- 폰트어썸 CSS 파일 로드 -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    
    <!-- 사용자 정의 CSS 파일 로드 -->
    <link href="/css/main.css" rel="stylesheet">
</head>
<body >
    <div class="container py-4">
        <!-- 사이트 본문 제목 -->
        <div class="text-center text-warning NanumMyeongjo fs-1 border-bottom border-warning">AI 스쿨랭</div>
        
        <!-- 상단 메뉴바 -->
        <div class="py-2  d-flex flex-wrap justify-content-between align-items-center mb-4 border-bottom border-secondary "  >
                <!-- 접속자 수 표시 -->
                <div class="px-4" style="color: #03e6e6;">
                    <i class="fa-solid fa-user-group"></i>
                    <sub id="connection-count">0</sub>
                </div>
                
                <!-- 날짜 선택 버튼 영역 -->
                <div id="date-buttons" class="align-items-center gap-2 "></div>
                
                <!-- 도움말과 토글 스위치 -->
                <div class="d-flex align-items-center ">
                    <button class="btn btn-link me-2" 
                            data-bs-toggle="modal" 
                            data-bs-target="#helpModal"
                            title="도움말"
                            >
                        <i class="fa-solid fa-circle-question text-warning" ></i>
                    </button>
                    <div class="form-check form-switch" title="카드 본문 보기/숨기기">
                        <input class="form-check-input bg-warning" type="checkbox" id="flexSwitchCheckDefault" checked
                        data-bs-toggle="collapse" data-bs-target=".swiper" 
                        aria-expanded="true" aria-controls="swiper">
                    </div>
                </div>
            </div>

        <!-- 로딩 스피너 -->
        <div class="loading">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
        </div>

        <!-- 급식 카드 컨테이너 -->
        <div class="row" id="meals-container">
            <!-- Cards will be inserted here -->
        </div>
    </div>

    <!-- 방문자 수 표시 -->
    <div class="visits-count">
        <i class="fas fa-users"></i> <span id="visit-counter"></span>
    </div>

    <!-- 도움말 모달 -->
    <div class="modal fade" id="helpModal" tabindex="-1" aria-labelledby="helpModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header" style="color: #f7ed8f; background-color: #013b3b;">
                    <div class="modal-title fs-5" id="helpModalLabel">도움말</div>
                    <div type="button" class="text-light" data-bs-dismiss="modal" aria-label="Close"><i class="fa-solid fa-xmark"></i></div>
                </div>
                <div class="modal-body " id="helpContent"   style="background-color: WhiteSmoke;">
                    <!-- 마크다운 내용이 여기에 로드됩니다 -->
                </div>
            </div>
        </div>
    </div>

    <!-- 외부 JavaScript 파일 로드 -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <!-- 사용자 정의 JavaScript 파일 로드 -->
    <script src="/js/main.js"></script>
    <script src="/js/webSocket.js"></script>
    
</body>
</html>
```

### main.css 분석

```
body {
    position: relative;
    font-family:'SCoreDream','NanumBarunGothic'; 
    font-size: 1em !important;
    background-color:  #00292f; 
   
  }
  .card-text {
      position: relative;
      font-family:'NanumBarunGothic'; 
      font-size: 1.05em !important;
  }
.loading {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.8);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}
.review-loading {
    display: none;
    text-align: center;
    padding: 10px;
}
.card {
    transition: transform 0.2s;
}
.card:hover {
    transform: translateY(-5px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}
.stars {
    letter-spacing: 2px;
    margin-bottom: 5px;
}
.nutri-score {
    color: #01a6a6;
}        
.pref-score {
    color: #00c5c5;
}

.visits-count {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: rgba(1, 62, 50, 0.9);
    color: white;
    padding: 10px 20px;
    border-radius: 25px;
    font-size: 0.9em;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    z-index: 1000;
}
#date-buttons{
    display: flex;
    justify-content: center;
    flex-wrap: wrap;

}
.date-btn {
    min-width: 120px;
}
.review-section {
    margin-top: 15px;
    padding-top: 15px;
    border-top: 1px solid rgba(0,0,0,0.1);
}
.card-col.highlight {
    animation: highlightAnimation 1s;
}

@keyframes highlightAnimation {
    from { background-color: #ffffcc; }
    to { background-color: transparent; }
}
.card-col {
    transition: transform 0.5s;
}

.card-col.moving {
    transform: translateY(-10px);
}
.reaction-btn.disabled {
    cursor: not-allowed;
    opacity: 0.6;
}

.review-section {
    margin-top: 1rem;
}

.review-text span {
    vertical-align: middle;
    text-align: justify; /* span 내부 텍스트도 양쪽 정렬 */
    width: 100%; /* span이 전체 너비를 사용하도록 */
    display: inline-block; /* 블록 레벨 정렬을 위해 */
}
.review-text {
    word-break: break-word;
    line-height: 1.5;
    text-align: justify;
}

.ai-review-content {
    display: inline;
}

.ai-review-content svg {
    display: inline-block;
    width: 20px;
    height: 20px;
    margin-right: 4px;
    vertical-align: -4px;
}
```

### main.js 분석

```
let currentDate = '';
let $mealsContainer = $('#meals-container');
let $loading = $('.loading');
let $dateButtons = $('#date-buttons');
let likesData = {};
$(document).ready(function() {
   
    $loading = $('.loading');
    $dateButtons = $('#date-buttons');
    likesData = {};
    // 날짜 버튼 초기화
    function initializeDateButtons() {
        const today = new Date();
        const dates = [];

        for (let i = -3; i <= 3; i++) {
            const date = new Date(today);
            date.setDate(today.getDate() + i);

            // 주말(토,일) 제외
            if (date.getDay() !== 0 && date.getDay() !== 6) {
                dates.push(date.toISOString().split('T')[0]);
            }
        }

        dates.forEach(date => {
            const button = $('<div>')
                .addClass('btn btn-outline-secondary date-btn')
                .attr('data-date', date)
                .text(new Date(date).toLocaleDateString('ko-KR', {
                    month: 'long',
                    day: 'numeric',
                    weekday: 'short'
                }));

            if (date === today.toISOString().split('T')[0]) {
                button.addClass('active');
            }

            $dateButtons.append(button);
        });

        fetchMeals(today.toISOString().split('T')[0]);
    }
    

    
    initializeDateButtons();
    updateVisitCount();
    // 도움말 모달 내용 로드
    $.ajax({
        url: '/help/guide.md',
        method: 'GET',
        success: function(text) {
            // 첫 번째 제목 줄 추출
            const title = text.match(/^#([^\n]*)\n/)[1];
            
            // 첫 번째 제목 줄 제거
            const contentWithoutTitle = text.replace(/^#[^\n]*\n/, '');
            
            // 모달 타이틀 업데이트 
            $('#helpModalLabel').text(title);
            
            // marked.js를 사용하여 마크다운을 HTML로 변환
            $('#helpContent').html(marked.parse(contentWithoutTitle));
        },
        error: function(error) {
            console.error('도움말을 불러오는데 실패했습니다:', error);
        }
    });
});
function updateVisitCount() {
    $.ajax({
        url: '/api/visits/total',
        method: 'GET',
        success: function(response) {
            $('#visit-counter').text(response.count);
        },
        error: function(error) {
            console.error('Error fetching visit count:', error);
        }
    });
}
function fetchMeals(date) {
    $loading.css('display', 'flex');
    currentDate = date;
    $mealsContainer.empty();

    $.ajax({
        url: `/api/meals/${date}`,
        method: 'GET',
        success: function(meals) {
            // 학교명으로 정렬
            meals.sort((a, b) => a.school_name.localeCompare(b.school_name, 'ko'));

            meals.forEach((meal, index) => {
                const cardHtml = createBasicCard(meal, index);
                const $cardCol = $(cardHtml);
                $mealsContainer.append($cardCol);

                // 초기 좋아요 수를 로컬 데이터에 저장
                likesData[meal.school_code] = 0; // 초기값 설정 (필요 시 변경)

                // 리뷰 로드
                loadReview(meal.school_code, date);
            });
        
            
            setInterval(function() {
                
                repositionCards('likes'); 
            }, 30000);
        },
        error: function(xhr, status, error) {
            console.error('Error:', error);
            $mealsContainer.html(`
                <div class="col-12 text-center">
                    <div class="alert alert-danger" role="alert">
                        데이터를 불러오는 중 오류가 발생했습니다.
                    </div>
                </div>
            `);
            $loading.fadeOut();
        },
        complete: function() {
            $loading.fadeOut();
        }
    });
}

function loadReview(schoolCode, date) {
    const card = $(`#school-${schoolCode}`);
    
    const cardCol = card.closest('.card-col');
    const reviewSection = card.find('.review-section');
    const reviewLoading = card.find('.review-loading');

    // AI Review 아이콘 SVG 문자열
    const aiIconSvg = `
    <svg viewBox="0 0 70 24" xmlns="http://www.w3.org/2000/svg" style="width: 60px; height: 22px; margin-right:0px; vertical-align: -4px;">
        <rect x="4" y="4" width="62" height="16" rx="3" fill="none" stroke="#4A90E2" stroke-width="1.5"/>
        <text x="35" y="15.5" font-family="Arial" font-size="10" fill="#4A90E2" text-anchor="middle" font-weight="bold">AI Review</text>
    </svg>`;
    
    reviewLoading.show();
    
    $.ajax({
        url: `/api/review/${date}/${schoolCode}`,
        method: 'GET',
        success: function(review) {
            const schoolName = $(`#school-${schoolCode}>.card-header`).text();
            
            if (review) {
                reviewSection.html(`
                    <div class="review-text">
                        <span class="ai-review-content">
                            ${aiIconSvg}${review.review}
                        </span>
                    </div>
                `);
                
                card.find('.nutri-score').html(createStars('nutri_score',review.nutri_score));
                card.find('.pref-score').html(createStars('pref_score',review.pref_score));

                // 총점 계산 및 저장 (리뷰 점수 합산)
                const totalScore = (review.nutri_score || 0) + (review.pref_score || 0);
                cardCol.data('totalScore', totalScore);

                // 초기 "좋아요" 수를 로컬 데이터에 저장
                likesData[schoolCode] = review.reactions.likes || 0;

                // "좋아요" UI 업데이트
                update_count_ReactionUI(card, review.reactions.likes);
                // 처음 로드 시 총점 순서 재정렬
                repositionCards('score');
            } else {
                reviewSection.html(`
                    <div class="alert alert-warning" role="alert">
                        리뷰가 존재하지 않습니다.
                    </div>
                `);
                cardCol.data('totalScore', 0);
            }

            // 페이지 로드 시 로컬 스토리지 확인 및 버튼 상태 업데이트
            let likedSchools = JSON.parse(localStorage.getItem('likedSchools')) || [];
            if (likedSchools.includes(schoolCode)) {
                card.find('.reaction-btn')
                    .removeClass('text-muted')
                    .addClass('text-primary disabled')
                    .attr('aria-disabled', 'true')
                    .off('click')
                    .css('pointer-events', 'none');
            }
        },
        error: function(xhr, status, error) {
            reviewSection.html(`
                <div class="alert alert-danger" role="alert">
                    리뷰를 불러오는 중 오류가 발생했습니다.
                </div>
            `);
            cardCol.data('totalScore', 0);
        },
        complete: function() {
            reviewLoading.hide();
        }
    });
    
}

function repositionCards(mode='score') {
    const $cardCols = $mealsContainer.children('.card-col').get();

    // 카드 컬럼들을 좋아요 수에 따라 정렬
    if (mode === 'likes') {
        $cardCols.sort(function(a, b) {
            const likesA = parseInt($(a).find('.likes-count').text()) || 0;
            const likesB = parseInt($(b).find('.likes-count').text()) || 0;

            return likesB - likesA; // 내림차순 정렬
        });
    } else {
        // 카드 컬럼들을 총점에 따라 정렬
        $cardCols.sort(function(a, b) {
            const scoreA = $(a).data('totalScore') || 0;
            const scoreB = $(b).data('totalScore') || 0;
            return scoreB - scoreA;
            });
    }

    // 정렬된 순서대로 애니메이션 적용 moveCards()
    // moveCards()
    
        $.each($cardCols, function(index, cardCol) {
            $mealsContainer.append(cardCol);
            $(cardCol).addClass('moving');
            setTimeout(function() {
                $(cardCol).removeClass('moving');
            }, 500); // 애니메이션 시간과 동일하게 설정
        });
  
}


function createStars(mode,score) {
    const fullStars = Math.floor(score);
    const hasHalfStar = score % 1 >= 0.5;
    let starsHtml = '';
    const title={
        'nutri_score'   :'영양학적 평가',
        'pref_score'    :'학생 선호도 측면 평가'
        }
    for (let i = 0; i < 5; i++) {
        if (i < fullStars) {
            starsHtml += '<i class="fas fa-star"></i>';
        } else if (i === fullStars && hasHalfStar) {
            starsHtml += '<i class="fas fa-star-half-alt"></i>';
        } else {
            starsHtml += '<i class="far fa-star"></i>';
        }
    }

    return `
        <div class="stars" title="${title[mode]}">
            ${starsHtml} <small class="text-muted">${score.toFixed(1)}</small>
        </div>
        
    `;
}

function createBasicCard(meal, index) {
    // 한 학교 식단 카드 생성
    return `
        <div class="col-md-6 col-lg-4 mb-4 card-col">
            <div class="card h-100 border border-warning" id="school-${meal.school_code}">
                <div class="card-header py-3 fs-5 text-light" style="background-color: #013b3b;">
                    ${meal.school_name}
                </div>
                <div class="card-body swiper collapse show">
                    <div class="card-text">${meal.lunch_menu}</div>
                    <div class="review-section">
                        <div class="review-loading text-center">
                            <div class="spinner-border spinner-border-sm text-primary" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            <span class="ms-2">리뷰 생성 중...</span>
                        </div>
                    </div>
                </div>
                <div class="card-footer d-flex justify-content-between align-items-center">
                    <div class="flex-grow-1 review-score text-center d-flex justify-content-center align-items-center gap-2">
                        <div class="nutri-score"></div>
                        <div class="pref-score"></div>
                    </div>
                    <div class="reactions-container text-center">
                        <span class="reaction-btn text-muted cursor-pointer" data-type="like" 
                        data-name="${meal.school_name}"
                        data-school="${meal.school_code}" aria-label="Like ${meal.school_name} School Meal" role="button">
                            <i class="fas fa-thumbs-up"></i>
                        </span>
                        <span class="likes-count">0</span>
                    </div>
                </div>
            </div>
        </div>
    `;
}
// 이벤트 핸들러
$(document).on('click', '.reaction-btn', function(event) {
    event.stopPropagation();
    
    const schoolCode = $(this).data('school');
    const schoolName = $(this).data('name');
    const reactionType = $(this).data('type');
    handleReaction(schoolCode, reactionType, currentDate);
});

$(document).on('click', '.date-btn', function(event) {
    event.stopPropagation();
    $('.date-btn').removeClass('active');
    $(this).addClass('active');
    fetchMeals($(this).data('date'));
});
function handleReaction(schoolCode, reactionType, date) {
    const card = $(`#school-${schoolCode}`);

    if (card.length === 0) {
        console.error(`학교 코드 ${schoolCode}에 해당하는 카드가 존재하지 않습니다.`);
        return;
    }

    
    let schoolLikes = localStorage.getItem(`${currentDate}-${schoolCode}-schoolLikes`) || 0
    
    
    // 좋아요 횟수가 5회 이상인 경우
    if (schoolLikes >= 5) {
        alert('한 학교 급식에 대한 좋아요는 최대 5회까지만 가능합니다.');
        return;
    }

    $.ajax({
        url: `/api/reaction/${date}/${schoolCode}/${reactionType}`,
        method: 'POST',
        success: function(response) {
            // 좋아요 횟수 증가 및 저장
            update_count_ReactionUI(card, response.likes);
            schoolLikes ++;
            localStorage.setItem(`${currentDate}-${schoolCode}-schoolLikes`, schoolLikes);
        },
        error: function(xhr, status, error) {
            alert('반응을 저장하는 중 오류가 발생했습니다.');
        }
    });
}
function update_count_ReactionUI(card, likes) {
    card.find('.likes-count').text(likes);

    if (likes === 0) {
        card.find('.reaction-btn').removeClass('text-primary').addClass('text-muted');
    } else {
        card.find('.reaction-btn').removeClass('text-muted').addClass('text-primary');
    }
}

```

### WebSocket 관리 모듈( webSocket.js) 분석
```
// WebSocket.js
let <span style="color: blue;">socket</span>; // WebSocket 객체를 전역 변수로 선언
let <span style="color: blue;">reconnectInterval</span> = 5000; // 초기 재접속 시도 간격 (밀리초)

$(document).ready(function() {
    // 웹소켓 연결 초기화
    socket = connectWebSocket();
    
    // 페이지를 떠날 때 WebSocket 연결을 종료
    $(window).on('beforeunload', function() {
        if (socket) {
            socket.close();
        }
    });
});

/**
 * WebSocket을 초기화하고 관리하는 함수
 * @returns {WebSocket} 생성된 WebSocket 객체
 */
function connectWebSocket() {
    // 이미 연결되어 있거나 연결 중인 경우 재접속 시도하지 않음
    if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) {
        console.log('이미 WebSocket이 연결되었거나 연결 중입니다.');
        return socket;
    }

    // localStorage에서 client_id 가져오기
    let clientId = localStorage.getItem('client_id');
    if (!clientId) {
        // 새로운 client_id 생성
        clientId = generateUUID();
        // localStorage에 client_id 저장
        localStorage.setItem('client_id', clientId);
    }

    // HTTPS 여부에 따라 적절한 WebSocket 프로토콜(wss/ws) 선택
    const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
    const socketUrl = `${protocol}://${window.location.host}/ws?client_id=${clientId}`;

    // WebSocket 객체 생성 및 연결
    socket = new WebSocket(socketUrl);
    
    // WebSocket이 연결되었을 때 실행되는 콜백
    socket.onopen = function() {
        console.log('WebSocket 연결됨');
        // 연결이 성공하면 재접속 간격 초기화
        reconnectInterval = 5000;
    };

    // WebSocket 에러 처리 핸들러
    socket.onerror = function(error) {
        console.error('WebSocket 에러 발생:', error);
        // 사용자에게 에러 알림 (선택 사항)
        alert('실시간 연결에 문제가 발생했습니다. 잠시 후 다시 시도해주세요.');
    };

    // 서버로부터 메시지를 받았을 때 실행되는 핸들러
    socket.onmessage = function(event) {
        try {
            const data = JSON.parse(event.data);
            handleWebSocketMessage(data);
        } catch (error) {
            console.error('메시지 처리 중 에러 발생:', error);
        }
    };

    // WebSocket 연결이 종료되었을 때 실행되는 핸들러
    socket.onclose = function() {
        console.log('WebSocket 연결 종료. 재접속 시도...');
        setTimeout(() => {
            // 재접속 시도 전에 재접속 간격을 지수 백오프 방식으로 증가
            reconnectInterval = Math.min(reconnectInterval * 2, 60000); // 최대 60초
            connectWebSocket();
        }, reconnectInterval);
    };

    return socket;
}

function generateUUID() {
    // UUID 생성 (보안 강화된 방식)
    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, function(c) {
        return (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16);
    });
}

/**
 * WebSocket으로부터 받은 메시지를 처리하는 함수
 * @param {Object} data - 서버로부터 받은 데이터 객체
 */
function handleWebSocketMessage(data) {
    switch(data.type) {
        case 'connection_count':
            // 접속자 수 업데이트 UI 처리
            $('#connection-count').text(data.count);
            break;
        case 'reaction':
            // 좋아요 수 업데이트 UI 처리
            const card = $(`#school-${data.school_code}`);
            update_count_ReactionUI(card, data.likes);
            break;
        default:
            console.warn('알 수 없는 메시지 타입:', data.type);
    }
}
```

## AI 스쿨랭  커스터마이징

### 1. 날자 선택 버튼을  다른 색으로 변경하기

### 2. 좋아요 클릭을 10회 까지 가능하도록 변경

### 3. 자유 커스터마이징 AI 이용   

